**Kotlin** - статически типизированный язык программирования для JVM, Android и браузера. Open-source-проект под лицензией Apache 2.0. Сопровождение исходного кода, инструментария, документации и даже этого веб-сайта осуществляется на GitHub.

Две главных особенности котлина - это его простота и полная совместимость с Java. Котлин создавался компанией, которая делает очень много продуктов на Java и которая хорошо разбирается в современных инструментах разработки. Запрос на новый язык витает в воздухе давно, но сделать такой язык, который бы позволил взять (огромную) готовую кодовую базу Java, обычных Java-разработчиков, дать им новый инструмент и бесшовно (но более эффективно) продолжать разработку — такого инструмента до появления котлина не существовало. Создатели нового языка, на мой взгляд, очень хорошо почувствовали потребности бизнеса и разработчиков: бизнесу дали возможность увеличить эффективность разработчиков, а разработчикам дать современный инструмент для разработки.

**Основные особенности языка:**

**Null safety**

Язык позволяет, определяя переменные, поля, константы и тд, указать, может ли в них храниться ссылка на null. Поднимает на новый уровень идею аннотаций вроде @Nullable и NotNull, позволяет умно приводить к не-nullable типу после проверки её на null. Надо отметить, что бывают случаи, когда эта особенность расходится с моим закостенелым разработкой на Java представлением о том как должны быть сделаны некоторые вещи, но после некоторого раздумья хорошее решение всегда находится.

```kotlin
/* вопросом помечаем, что может прийти null */
fun someFunction(someNullableParam:SomeType?) {
    if(someNullableParam != null) {
         // smart cast. Компилятор видит, что передаваемое 
         // значение не null и разрешает его передать в функцию
        anotherFunction(someNullableParam)
    }
}

/* здесь же уже null не пройдет, в попытке передать 
 * null или nullable значение компилятор выдаст ошибку */
fun anotherFunction(someParam:SomeType) {
    // делаем что-то без опаски, что переданное значение null
}
```

**Выведение типов**

Котлин почти везде где возможно, умеет вывести тип, однако тип всё же придется определить для публичных методов и свойств, что очень разумно:

```kotlin
// Kotlin в курсе, что здесь List<Char>
val result = sequenceOf(10).map { it.toString() }.flatMap { it.toCharArray().asSequence() }.toList()
```

**Extension methods**

Заключается в возможности определить метод для типа отдельно от его (типа) объявления. Такая функция, конечно, не будет виртуальной и никак не меняет класса, которому мы добавляем метод, однако позволяет добавить как утилитарную функциональность для уже существующего кода, так и разгрузить интерфейс от этих же утилитарных методов.

```kotlin
interface Vector2 {

    val x:Float // это не поле, а ридонли свойство (property)
    val y:Float // в Java были бы методы getX() и getY()

}

/* Extension property. Без поля в классе, просто getLength() */
val Vector2.length:Float
    get() = (x * x + y  * y).sqrt() // притворимся, что такая extension-функция для Float уже существует

/* переопределяем оператор + */
operator fun Vector2.plus(other:Vector2):Vector2 = createVector(x+this.x, y+this.y) // какой-то способ создать новый вектор

/* без тела, после знака = пишем одно выражение */
fun Vector2.dot(x: Float, y: Float): Float = x * this.x + y * this.y

/* Помечая функцию с одним параметром как infix, 
 * мы позволяем вызывать её через пробел: v1 dot v2 */
infix fun Vector2.dot(vec2: Vector2): Float = dot(vec2.x, vec2.y)

fun usage(vec1:Vector2, vec2:Vector2) {

    val dotProduct = vec1 dot vec2
    val sum = vec1 + vec2 // на выходе новый вектор
    val length = sum.length // обращаемся просто как к свойству

}
```

**Лямбды**

Конечно, как любой современный язык с претензией на возможности функцинального программирования, у котлина функция — это сущность первого класса, если переводить дословно. Т.е. функции можно не только объявлять прямо в пакете (из джавы они видны всё равно в классах — по имени файла), но и передавать в качестве параметров, возвращать из других функций и тд. И сейчас, конечно, никого этим не удивишь, но например в сравнении с Java, где синтаксически функций как таковых нет (а только функциональные интерфейсы), в котлине полноценный синтаксис для объявления функции:

```kotlin
/* передаем в одну функцию другую -- принимает в параметр Int
 * и Int же возвращает. Возвращаем её же, только с фиксированным 
 * значением в качестве параметра */
fun passTen(func: (Int)->Int ): ()->Int {
    return { func(10) }
}
```

**Extension-лямбды**

Позволяет определить лямбду, которая будет еще и extension-методом.

```kotlin
class World(val name:String = "world")

val printName:World.()->Unit = { 
     // интерполяцией в синтаксисе языка сейчас уже 
     // никого не привлечь на темную сторону
    println("Hello $name")
}

val world = World()

 // вызываем нашу функцию как будто это метод нашего класса!
world.printName()
```

**Inline-фукнции**

Помечая функцию как inline мы просим компилятор поместить её по месту использования. Чаще всего такими вещами занимается рантайм, но есть кейзы, когда мы точно знаем, что фукнция это просто шорткат для какого-то действия — особенно эффективно это работает с передаваемыми лямбдами:

```kotlin
/* передаваемой лямбдой block сейчас уже никого не удивишь.
 * Главно, что лишних затрат на вызов этой функции не будет вообще, 
 * иногда мне кажется, что это что-то вроде макросов */
inline fun lock(lock:Lock, block:()->Unit) {
    lock.lock()
    try { 
        block()
    } finally {
        lock.unlock()
    }
}

fun usage() {
    lock(Lock()) {
        // делаем что-то внутри блокировки
    }
}
```

**Делегирование**

В котлине есть два типа делегирования. Первый, который позволяет делегировать все методы реализуемого интерфейса к какому-то инстансу этого типа:

```kotlin
interface Connection {

    fun connect()

}

/* здесь мы видим стандартный для котлина синтаксис определения 
 * класса вместе с параметрами конструктора и свойствами -- 
 * в данном случае connection будет и в конструкторе и в поле. 
 * Есть возможность определить и множественный конструктор 
 * см https://kotlinlang.org/docs/reference/classes.html#constructors
 * И, наконец, мы видим что класс реализует интерфейс Connection, все методы
 * которого делегируются к переданному в конструктор экземпляру Connection-а.
 * При желании их конечно можно переопределить в теле класса */
class ConnectionWrapper(val connection:Connection) : Connection by connection
```

У этого синтаксиса есть ряд ограничений. Например, инстанс для делегирования должен быть известен до вызова конструктора.

Второй тип делегирования — это delegated properties. Позволяет определить объект с методами get (и set для var), к которым будет осуществляться делегирование доступа при обращении к свойству объекта.

```kotlin
class Foo {
    
    /* это делегат из стандартной библиотеки, 
       позволяет отложить инициализацию поля 
       до первого обращения к нему */ 
    private val someProeprty by lazy { HavyType() }

}
```

**Generics**

Создатели котлина несколько улучшили Java-дженерики. Из-за совместимости с джавой не всё получилось как хотелось бы, но им удалось исправить много неприятных моментов, которые не учли их предшественники при работе над Java 5.

**Деструктуризация**

```kotlin
val (first, second) = someFunc()
```

Чтобы такой код заработал, возвращаемое значение из someFunc() должно быть типа, у которого есть (можно extension) методы component1(), component2():

```kotlin
class Foo {
    fun component1():String = "test"
    fun component2():Int = 10
}
fun someFunc():Foo = Foo()

// или так, to -- в это такой infix extension-метод определенный 
// для Any, который создает экземпляр класса Pair, метод hashMapOf
// в свою очередь принимает vararg параметр таких пар
val map = hashMapOf(1 to "test")
for ((id, name) in map) {
    //  такой синтаксис возможен, потому что для Map-а определен метод iterator()
    // возвращающий набор Map.Entry, а для него в свою очередь определены два
    // extension-метода component1() и component2()
}
```

**Data-классы**

```kotlin
data class Bean(val a:String, val b:Int)
```

Создает бин с полями + автогенерирует equals+hashCode+toString()+componentN из раздела выше, что позволяет писать такой код:

```kotlin
fun someFunc():Bean = Bean("test", 10)
val (a, b) = someFunc()
```
